<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/test/java/pt/feup/tvvs/pacman/controller/menu/MenuControllerWhiteBoxTests.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/pt/feup/tvvs/pacman/controller/menu/MenuControllerWhiteBoxTests.java" />
              <option name="originalContent" value="package pt.feup.tvvs.pacman.controller.menu;&#10;&#10;public class MenuControllerWhiteBoxTests {&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package pt.feup.tvvs.pacman.controller.menu;&#10;&#10;import com.googlecode.lanterna.TextColor;&#10;import org.junit.jupiter.api.Test;&#10;import org.mockito.ArgumentCaptor;&#10;import pt.feup.tvvs.pacman.Game;&#10;import pt.feup.tvvs.pacman.audio.AudioManager;&#10;import pt.feup.tvvs.pacman.audio.AudioPlayer;&#10;import pt.feup.tvvs.pacman.gui.GUI;&#10;import pt.feup.tvvs.pacman.model.Position;&#10;import pt.feup.tvvs.pacman.model.menu.Menu;&#10;import pt.feup.tvvs.pacman.model.menu.MenuOptions;&#10;import pt.feup.tvvs.pacman.model.menu.element.TextBox;&#10;&#10;import java.awt.FontFormatException;&#10;import java.io.IOException;&#10;import java.net.URISyntaxException;&#10;import java.util.List;&#10;&#10;import static org.assertj.core.api.Assertions.assertThat;&#10;import static org.mockito.Mockito.*;&#10;&#10;public class MenuControllerWhiteBoxTests {&#10;&#10;    static class TestMenuController extends MenuController&lt;Menu&gt; {&#10;        public TestMenuController(Menu model, AudioManager audioManager) {&#10;            super(model, audioManager);&#10;        }&#10;&#10;        public float callHandleVolumeChange(Game game) {&#10;            return handleVolumeChange(game);&#10;        }&#10;&#10;        public GUI.SCREEN_RESOLUTION callIncrement(GUI.SCREEN_RESOLUTION s) {&#10;            return incrementResolution(s);&#10;        }&#10;&#10;        public GUI.SCREEN_RESOLUTION callDecrement(GUI.SCREEN_RESOLUTION s) {&#10;            return decrementResolution(s);&#10;        }&#10;&#10;        // expose step as public (inherited) so no wrapper needed&#10;    }&#10;&#10;    private Menu createSimpleMenu() {&#10;        return new Menu() {&#10;            @Override&#10;            protected java.util.List&lt;TextBox&gt; createOptions() {&#10;                return List.of(new TextBox(&quot;one&quot;, new Position(0,0), new TextColor.RGB(255,255,255)),&#10;                        new TextBox(&quot;two&quot;, new Position(0,1), new TextColor.RGB(255,255,255)));&#10;            }&#10;&#10;            @Override&#10;            protected TextBox createTitle() {&#10;                return new TextBox(&quot;title&quot;, new Position(0,0), new TextColor.RGB(255,255,255));&#10;            }&#10;        };&#10;    }&#10;&#10;    private static class MenuOptionsImpl extends Menu implements MenuOptions {&#10;        private boolean resolutionSelected;&#10;        private boolean masterVolumeSelected;&#10;        private float masterVolume;&#10;        private GUI.SCREEN_RESOLUTION resolution;&#10;&#10;        MenuOptionsImpl(boolean resolutionSelected, boolean masterVolumeSelected) {&#10;            this.resolutionSelected = resolutionSelected;&#10;            this.masterVolumeSelected = masterVolumeSelected;&#10;            initializeOptions();&#10;        }&#10;&#10;        @Override&#10;        public boolean ResolutionSelected() {&#10;            return resolutionSelected;&#10;        }&#10;&#10;        @Override&#10;        public boolean MasterVolumeSelected() {&#10;            return masterVolumeSelected;&#10;        }&#10;&#10;        @Override&#10;        public void setMasterVolume(float volume) {&#10;            this.masterVolume = volume;&#10;        }&#10;&#10;        @Override&#10;        public void setResolution(GUI.SCREEN_RESOLUTION newResolution) {&#10;            this.resolution = newResolution;&#10;            // also update the option text to simulate behavior&#10;            getOptions().get(2).setText(&quot;Resolution: &quot; + newResolution);&#10;        }&#10;&#10;        public GUI.SCREEN_RESOLUTION getResolution() {&#10;            return resolution;&#10;        }&#10;&#10;        public float getMasterVolume() {&#10;            return masterVolume;&#10;        }&#10;&#10;        @Override&#10;        protected java.util.List&lt;TextBox&gt; createOptions() {&#10;            // ensure there are at least 4 options (single/multi/resolution/volume/exit)&#10;            return List.of(new TextBox(&quot;Single player&quot;, new Position(0,0), new TextColor.RGB(255,255,255)),&#10;                    new TextBox(&quot;Multi player&quot;, new Position(0,1), new TextColor.RGB(255,255,255)),&#10;                    new TextBox(&quot;Resolution: 360p&quot;, new Position(0,2), new TextColor.RGB(255,255,255)),&#10;                    new TextBox(&quot;Master Volume: 5&quot;, new Position(0,3), new TextColor.RGB(255,255,255)),&#10;                    new TextBox(&quot;Exit&quot;, new Position(0,4), new TextColor.RGB(255,255,255)));&#10;        }&#10;&#10;        @Override&#10;        protected TextBox createTitle() {&#10;            return new TextBox(&quot;title&quot;, new Position(0,0), new TextColor.RGB(255,255,255));&#10;        }&#10;    }&#10;&#10;    @Test&#10;    public void constructor_registersAudios_and_setsVolumes() {&#10;        AudioManager audioManager = mock(AudioManager.class);&#10;        AudioPlayer sel = mock(AudioPlayer.class);&#10;        AudioPlayer conf = mock(AudioPlayer.class);&#10;        when(audioManager.getAudio(&quot;menuSelect&quot;)).thenReturn(sel);&#10;        when(audioManager.getAudio(&quot;menuConfirmSelection&quot;)).thenReturn(conf);&#10;&#10;        Menu model = mock(Menu.class);&#10;        new TestMenuController(model, audioManager);&#10;&#10;        verify(audioManager).addAudio(&quot;menuSelect&quot;, &quot;Audio/menuSelect.wav&quot;);&#10;        verify(audioManager).getAudio(&quot;menuSelect&quot;);&#10;        verify(audioManager).addAudio(&quot;menuConfirmSelection&quot;, &quot;Audio/menuConfirmSelection.wav&quot;);&#10;        verify(audioManager).getAudio(&quot;menuConfirmSelection&quot;);&#10;        verify(sel).setVolume(0.25f);&#10;        verify(conf).setVolume(0.2f);&#10;    }&#10;&#10;    @Test&#10;    public void handleVolumeChange_whenMasterIsOne_setsToPointOne() {&#10;        AudioManager audioManager = mock(AudioManager.class);&#10;        AudioPlayer sel = mock(AudioPlayer.class);&#10;        AudioPlayer conf = mock(AudioPlayer.class);&#10;        when(audioManager.getAudio(&quot;menuSelect&quot;)).thenReturn(sel);&#10;        when(audioManager.getAudio(&quot;menuConfirmSelection&quot;)).thenReturn(conf);&#10;&#10;        Menu model = createSimpleMenu();&#10;        TestMenuController controller = new TestMenuController(model, audioManager);&#10;&#10;        Game game = mock(Game.class);&#10;        GUI gui = mock(GUI.class);&#10;        when(game.getGui()).thenReturn(gui);&#10;        when(game.getAudioManager()).thenReturn(audioManager);&#10;        when(audioManager.getMasterVolume()).thenReturn(1f);&#10;&#10;        float nv = controller.callHandleVolumeChange(game);&#10;        assertThat(nv).isEqualTo(0.1f);&#10;        verify(gui).clear();&#10;        verify(audioManager).setMasterVolume(0.1f);&#10;    }&#10;&#10;    @Test&#10;    public void handleVolumeChange_roundsProperly() {&#10;        AudioManager audioManager = mock(AudioManager.class);&#10;        AudioPlayer sel = mock(AudioPlayer.class);&#10;        AudioPlayer conf = mock(AudioPlayer.class);&#10;        when(audioManager.getAudio(&quot;menuSelect&quot;)).thenReturn(sel);&#10;        when(audioManager.getAudio(&quot;menuConfirmSelection&quot;)).thenReturn(conf);&#10;&#10;        Menu model = createSimpleMenu();&#10;        TestMenuController controller = new TestMenuController(model, audioManager);&#10;&#10;        Game game = mock(Game.class);&#10;        GUI gui = mock(GUI.class);&#10;        when(game.getGui()).thenReturn(gui);&#10;        when(game.getAudioManager()).thenReturn(audioManager);&#10;        when(audioManager.getMasterVolume()).thenReturn(0.94f);&#10;&#10;        float nv = controller.callHandleVolumeChange(game);&#10;        // 0.94 + 0.1 = 1.04 -&gt; *10 = 10.4 -&gt; round = 10 -&gt; /10 = 1.0f&#10;        assertThat(nv).isEqualTo(1.0f);&#10;        verify(audioManager).setMasterVolume(1.0f);&#10;    }&#10;&#10;    @Test&#10;    public void step_up_and_down_calls_selectPrevious_and_next() throws Exception {&#10;        AudioManager audioManager = mock(AudioManager.class);&#10;        AudioPlayer sel = mock(AudioPlayer.class);&#10;        AudioPlayer conf = mock(AudioPlayer.class);&#10;        when(audioManager.getAudio(&quot;menuSelect&quot;)).thenReturn(sel);&#10;        when(audioManager.getAudio(&quot;menuConfirmSelection&quot;)).thenReturn(conf);&#10;&#10;        Menu model = mock(Menu.class);&#10;        TestMenuController controller = new TestMenuController(model, audioManager);&#10;&#10;        Game game = mock(Game.class);&#10;        controller.step(game, List.of(GUI.ACTION.UP), 0);&#10;        verify(sel).playOnce();&#10;        verify(model).selectPreviousOption();&#10;&#10;        controller.step(game, List.of(GUI.ACTION.DOWN), 0);&#10;        verify(sel, times(2)).playOnce();&#10;        verify(model).selectNextOption();&#10;    }&#10;&#10;    @Test&#10;    public void step_left_right_onResolution_calls_setResolution_and_play() throws Exception {&#10;        AudioManager audioManager = mock(AudioManager.class);&#10;        AudioPlayer sel = mock(AudioPlayer.class);&#10;        AudioPlayer conf = mock(AudioPlayer.class);&#10;        when(audioManager.getAudio(&quot;menuSelect&quot;)).thenReturn(sel);&#10;        when(audioManager.getAudio(&quot;menuConfirmSelection&quot;)).thenReturn(conf);&#10;&#10;        MenuOptionsImpl menuOptions = new MenuOptionsImpl(true, false);&#10;        Menu model = menuOptions;&#10;&#10;        TestMenuController controller = new TestMenuController(model, audioManager);&#10;        Game game = mock(Game.class);&#10;        when(game.getResolution()).thenReturn(GUI.SCREEN_RESOLUTION._360p);&#10;&#10;        controller.step(game, List.of(GUI.ACTION.RIGHT), 0);&#10;        verify(game).setResolution(GUI.SCREEN_RESOLUTION._540p);&#10;        assertThat(menuOptions.getResolution()).isEqualTo(GUI.SCREEN_RESOLUTION._540p);&#10;        verify(sel).playOnce();&#10;&#10;        // test LEFT&#10;        when(game.getResolution()).thenReturn(GUI.SCREEN_RESOLUTION._540p);&#10;        controller.step(game, List.of(GUI.ACTION.LEFT), 0);&#10;        verify(game).setResolution(GUI.SCREEN_RESOLUTION._360p);&#10;        assertThat(menuOptions.getResolution()).isEqualTo(GUI.SCREEN_RESOLUTION._360p);&#10;    }&#10;&#10;    @Test&#10;    public void step_left_right_onMasterVolume_changesVolume_and_clears_gui() throws Exception {&#10;        AudioManager audioManager = mock(AudioManager.class);&#10;        AudioPlayer sel = mock(AudioPlayer.class);&#10;        AudioPlayer conf = mock(AudioPlayer.class);&#10;        when(audioManager.getAudio(&quot;menuSelect&quot;)).thenReturn(sel);&#10;        when(audioManager.getAudio(&quot;menuConfirmSelection&quot;)).thenReturn(conf);&#10;&#10;        MenuOptionsImpl menuOptions = new MenuOptionsImpl(false, true);&#10;        Menu model = menuOptions;&#10;&#10;        TestMenuController controller = new TestMenuController(model, audioManager);&#10;        Game game = mock(Game.class);&#10;        GUI gui = mock(GUI.class);&#10;        when(game.getGui()).thenReturn(gui);&#10;        when(game.getAudioManager()).thenReturn(audioManager);&#10;        when(audioManager.getMasterVolume()).thenReturn(0.5f);&#10;&#10;        controller.step(game, List.of(GUI.ACTION.RIGHT), 0);&#10;        // newVolume = min(0.5+0.1,1.0) =&gt; 0.6 -&gt; rounded 0.6&#10;        verify(audioManager).setMasterVolume(0.6f);&#10;        assertThat(menuOptions.getMasterVolume()).isEqualTo(0.6f);&#10;        verify(gui).clear();&#10;        verify(sel).playOnce();&#10;&#10;        // test LEFT&#10;        when(audioManager.getMasterVolume()).thenReturn(0.6f);&#10;        controller.step(game, List.of(GUI.ACTION.LEFT), 0);&#10;        verify(audioManager).setMasterVolume(0.5f);&#10;        assertThat(menuOptions.getMasterVolume()).isEqualTo(0.5f);&#10;    }&#10;&#10;    @Test&#10;    public void increment_and_decrement_resolution_cover_all_cases() {&#10;        AudioManager audioManager = mock(AudioManager.class);&#10;        AudioPlayer sel = mock(AudioPlayer.class);&#10;        AudioPlayer conf = mock(AudioPlayer.class);&#10;        when(audioManager.getAudio(&quot;menuSelect&quot;)).thenReturn(sel);&#10;        when(audioManager.getAudio(&quot;menuConfirmSelection&quot;)).thenReturn(conf);&#10;&#10;        Menu model = createSimpleMenu();&#10;        TestMenuController controller = new TestMenuController(model, audioManager);&#10;&#10;        GUI.SCREEN_RESOLUTION[] values = GUI.SCREEN_RESOLUTION.values();&#10;        for (GUI.SCREEN_RESOLUTION v : values) {&#10;            GUI.SCREEN_RESOLUTION inc = controller.callIncrement(v);&#10;            GUI.SCREEN_RESOLUTION dec = controller.callDecrement(v);&#10;            assertThat(inc).isNotNull();&#10;            assertThat(dec).isNotNull();&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/test/java/pt/feup/tvvs/pacman/states/StateWhiteBoxTests.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/test/java/pt/feup/tvvs/pacman/states/StateWhiteBoxTests.java" />
              <option name="originalContent" value="package pt.feup.tvvs.pacman.states;&#10;&#10;public class StateWhiteBoxTests {&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package pt.feup.tvvs.pacman.states;&#10;&#10;import org.junit.jupiter.api.Test;&#10;import pt.feup.tvvs.pacman.Game;&#10;import pt.feup.tvvs.pacman.audio.AudioManager;&#10;import pt.feup.tvvs.pacman.controller.Controller;&#10;import pt.feup.tvvs.pacman.gui.GUI;&#10;import pt.feup.tvvs.pacman.viewer.Viewer;&#10;&#10;import java.io.IOException;&#10;import java.net.URISyntaxException;&#10;import java.awt.FontFormatException;&#10;import java.util.Collections;&#10;&#10;import static org.assertj.core.api.Assertions.assertThat;&#10;import static org.assertj.core.api.Assertions.assertThatThrownBy;&#10;import static org.mockito.Mockito.*;&#10;&#10;public class StateWhiteBoxTests {&#10;&#10;    @Test&#10;    public void constructor_initializes_model_and_audio_and_uses_overrides() throws Exception {&#10;        String model = &quot;myModel&quot;;&#10;        AudioManager audio = mock(AudioManager.class);&#10;        Viewer&lt;String&gt; viewer = mock(Viewer.class);&#10;        Controller&lt;String&gt; controller = mock(Controller.class);&#10;&#10;        State&lt;String&gt; state = new State&lt;String&gt;(model, audio) {&#10;            @Override&#10;            public Viewer&lt;String&gt; createViewer() throws IOException {&#10;                return viewer;&#10;            }&#10;&#10;            @Override&#10;            public Controller&lt;String&gt; createController(AudioManager audioManager) {&#10;                return controller;&#10;            }&#10;        };&#10;&#10;        assertThat(state.getModel()).isSameAs(model);&#10;        assertThat(state.getAudioManager()).isSameAs(audio);&#10;&#10;        // calling step should delegate to provided controller and viewer&#10;        GUI gui = mock(GUI.class);&#10;        when(gui.getNextAction()).thenReturn(Collections.emptyList());&#10;        Game game = mock(Game.class);&#10;&#10;        state.step(game, gui, 42L);&#10;&#10;        verify(controller).step(eq(game), anyList(), eq(42L));&#10;        verify(viewer).drawElement(eq(gui), eq(model), eq(42L));&#10;    }&#10;&#10;    @Test&#10;    public void step_propagates_controller_exceptions() throws Exception {&#10;        String model = &quot;m&quot;;&#10;        AudioManager audio = mock(AudioManager.class);&#10;        Controller&lt;String&gt; controller = mock(Controller.class);&#10;        Viewer&lt;String&gt; viewer = mock(Viewer.class);&#10;&#10;        doThrow(new IOException(&quot;boom&quot;)).when(controller).step(any(), anyList(), anyLong());&#10;&#10;        State&lt;String&gt; state = new State&lt;String&gt;(model, audio) {&#10;            @Override&#10;            public Viewer&lt;String&gt; createViewer() throws IOException {&#10;                return viewer;&#10;            }&#10;&#10;            @Override&#10;            public Controller&lt;String&gt; createController(AudioManager audioManager) {&#10;                return controller;&#10;            }&#10;        };&#10;&#10;        GUI gui = mock(GUI.class);&#10;        when(gui.getNextAction()).thenReturn(Collections.emptyList());&#10;        Game game = mock(Game.class);&#10;&#10;        assertThatThrownBy(() -&gt; state.step(game, gui, 7L)).isInstanceOf(IOException.class).hasMessageContaining(&quot;boom&quot;);&#10;    }&#10;&#10;    @Test&#10;    public void step_propagates_uri_and_font_exceptions_from_viewer_draw() throws Exception {&#10;        String model = &quot;m&quot;;&#10;        AudioManager audio = mock(AudioManager.class);&#10;        Controller&lt;String&gt; controller = mock(Controller.class);&#10;        Viewer&lt;String&gt; viewer = mock(Viewer.class);&#10;&#10;        // make viewer.drawElement throw URISyntaxException wrapped in a RuntimeException (method doesn't declare checked exceptions)&#10;        doThrow(new RuntimeException(new URISyntaxException(&quot;/x&quot;,&quot;err&quot;))).when(viewer).drawElement(any(), any(), anyLong());&#10;&#10;        State&lt;String&gt; state = new State&lt;String&gt;(model, audio) {&#10;            @Override&#10;            public Viewer&lt;String&gt; createViewer() throws IOException {&#10;                return viewer;&#10;            }&#10;&#10;            @Override&#10;            public Controller&lt;String&gt; createController(AudioManager audioManager) {&#10;                return controller;&#10;            }&#10;        };&#10;&#10;        GUI gui = mock(GUI.class);&#10;        when(gui.getNextAction()).thenReturn(Collections.emptyList());&#10;        Game game = mock(Game.class);&#10;&#10;        assertThatThrownBy(() -&gt; state.step(game, gui, 8L)).hasRootCauseInstanceOf(URISyntaxException.class);&#10;    }&#10;&#10;    @Test&#10;    public void step_propagates_font_format_exception_wrapped() throws Exception {&#10;        String model = &quot;m&quot;;&#10;        AudioManager audio = mock(AudioManager.class);&#10;        Controller&lt;String&gt; controller = mock(Controller.class);&#10;        Viewer&lt;String&gt; viewer = mock(Viewer.class);&#10;&#10;        // make viewer.drawElement throw FontFormatException wrapped in RuntimeException&#10;        doThrow(new RuntimeException(new FontFormatException(&quot;bad font&quot;))).when(viewer).drawElement(any(), any(), anyLong());&#10;&#10;        State&lt;String&gt; state = new State&lt;String&gt;(model, audio) {&#10;            @Override&#10;            public Viewer&lt;String&gt; createViewer() throws IOException {&#10;                return viewer;&#10;            }&#10;&#10;            @Override&#10;            public Controller&lt;String&gt; createController(AudioManager audioManager) {&#10;                return controller;&#10;            }&#10;        };&#10;&#10;        GUI gui = mock(GUI.class);&#10;        when(gui.getNextAction()).thenReturn(Collections.emptyList());&#10;        Game game = mock(Game.class);&#10;&#10;        assertThatThrownBy(() -&gt; state.step(game, gui, 9L)).hasRootCauseInstanceOf(FontFormatException.class);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>